class Environment is subclass of GLOBAL

types 

Input = (CustomerChoice * seq of RecItemInline * seq of BoxItemInline);
RecItem = (RecycleMark * Barcode * Shape);
RecItemInline	= (Time * RecItem);
BoxItemInline  = (Time * (BoxType * seq of RecItem));
RecycleInline = RecItemInline | BoxItemInline;
Outline = (Time * CustomerChoice * real);

public RecycleEntry ::
	time : nat
	recycle : Recycle;

instance variables
 
io : IO := new IO();

busy : bool := true;

outlines : seq of Outline := [];

cusTime : CustomerChoice := nil;

singleItems : seq of RecycleEntry := [];
boxes : seq of RecycleEntry := [];

operations 

public Environment : seq of char  ==> Environment
Environment(fname) ==
	def mk_(-,mk_(choice, itemInput, boxInput)) = io.freadval[Input](fname)
	in (
	singleItems := [MakeRecycle(x) | x in seq itemInput];
	boxes := [MakeRecycle(x) | x in seq boxInput];
	cusTime := choice);
	
private CreateSignal : () ==> ()
CreateSignal() ==
	(if len singleItems > 0 or len boxes > 0 
	then	
		(dcl 
			curTime : Time := World`timerRef.GetTime(),
			boxDone : bool := false,
			itemDone : bool := false;
		busy := true;
		while not boxDone and not itemDone 
		do
			(if len singleItems > 0
			then
				(let 
					item = hd singleItems
				in 
					if item.time <= curTime
					then
						(RecycleMachine`singleItemConveyor.InputRecycle(item.recycle);
						singleItems := tl singleItems;
						itemDone := len singleItems = 0)
					else itemDone := true)
			else itemDone := true;
			if len boxes > 0 
			then
				(let 
					box = hd boxes
				in 
					if box.time <= curTime
					then
						(RecycleMachine`boxConveyor.InputRecycle(box.recycle);
						boxes := tl boxes;
						boxDone := len boxes = 0;)
					else boxDone := true)
			else boxDone := true))
	else 
		busy := false);

public HandleEvent : Time * CustomerChoice * real ==> ()
HandleEvent(pt, pcc, pa) ==
	outlines := outlines ^ [mk_(pt, pcc, pa)];
	
public HandleEvent : RecycleMachineState ==> ()
HandleEvent(prms) ==
	cases prms: 
		<ItemInvalid> -> def -= RecycleMachine`singleItemConveyor.RemoveRecycle() in skip,
		<BoxInvalid> -> def -= RecycleMachine`boxConveyor.RemoveRecycle() in skip,
		<TooManyItems> -> (dcl rec : Recycle := RecycleMachine`singleItemConveyor.RemoveRecycle();
											singleItems := singleItems  ^ [mk_RecycleEntry(World`timerRef.GetTime() + 10, rec)]),
		<TooManyBoxes> -> (dcl rec : Recycle := RecycleMachine`boxConveyor.RemoveRecycle();
											boxes := boxes  ^ [mk_RecycleEntry(World`timerRef.GetTime() + 10, rec)]),
		<ItemStorageFull> -> RecycleMachine`storage.ClearItemStorage(),
		<BoxStorageFull> -> RecycleMachine`storage.ClearBoxStorage()
	end;
	
private IsFinished : () ==> bool
IsFinished() ==
	return boxes = [] and singleItems = [] and not busy;

public ShowResult : () ==> ()
ShowResult() ==
	def -= io.writeval[seq of Outline](outlines) in skip;

public Run : () ==> ()
Run() ==
	(
	while not (IsFinished()
						and
						RecycleMachine`recycleMachineController.IsFinished()
						and
						RecycleMachine`singleItemConveyor.IsFinished()
						and
						RecycleMachine`boxConveyor.IsFinished())
	do
		(
		CreateSignal();
		RecycleMachine`recycleMachineController.Step();
		RecycleMachine`singleItemConveyor.Step();
		RecycleMachine`boxConveyor.Step();
		World`timerRef.StepTime();
		);
  if cusTime = <Donate>
  then RecycleMachine`ui.Donate() 
  else RecycleMachine`ui.GetReceipt();
	);

functions

private MakeRecycle : RecycleInline -> RecycleEntry
MakeRecycle(rec) ==
	if is_RecycleMark(rec.#2.#1)
	then 
		mk_RecycleEntry(rec.#1, mk_RecycleItem(rec.#2.#1, rec.#2.#2, rec.#2.#3))
 	else 
		mk_RecycleEntry(rec.#1, mk_RecycleBox(rec.#2.#1, 
			[mk_RecycleItem(recI.#1, recI.#2, recI.#3) | recI in seq rec.#2.#2]));

end Environment