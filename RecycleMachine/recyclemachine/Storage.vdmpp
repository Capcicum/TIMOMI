class Storage is subclass of GLOBAL

instance variables

itemStorage : set of Item := {};
inv forall i,j in set itemStorage & i<> j => i.id <> j.id and card itemStorage <= itemLimit; 

boxStorage : set of Box := {};
inv forall i,j in set boxStorage & i <> j => i.id <> j.id and 
card boxStorage <= boxLimit 
and forall k,l in set dom merge {x.ri | x in set boxStorage} & k<>l => k.id <> l.id
and forall m in set boxStorage & card dom m.ri <= m.lg;

itemLimit : nat;
boxLimit : nat;

operations

public Storage : nat * nat ==> Storage
Storage(pil, pbl) ==
	(itemLimit := pil;
	boxLimit := pbl);
	
public GetItemStorage : () ==> set of Recycle
GetItemStorage() ==
	return itemStorage;
	
public GetBoxStorage : () ==> set of Recycle
GetBoxStorage() ==
	return boxStorage;
	
public Store : [Recycle] ==> ()
Store(prr) ==
	if is_Box(prr)
	then if ExistValidEmptyBox(prr.ty)
	then 
	then itemStorage := itemStorage ^ [prr]
	else if is_Box(prr) 
	then boxStorage := boxStorage ^ [prr];
	
public ExistValidEmptyBox : Shape ==> bool
ExistValidEmptyBox(ps) ==
	return exists i in set boxStorage & i.ty = ps and card dom i.ri < i.lg;

public StorageAvailableItem : () ==> bool
StorageAvailableItem() ==
	return card itemStorage < itemLimit;
	
public StorageAvailableBox : () ==> bool 
StorageAvailableBox() ==
	return (card boxStorage) < boxLimit;
	
public ClearItemStorage : () ==> ()
ClearItemStorage() ==
	RemoveItems(itemLimit);
	
public ClearBoxStorage : () ==> ()
ClearBoxStorage() ==
	RemoveBoxes(boxLimit);

public RemoveItems : nat ==> ()
RemoveItems(pcount) ==
	if len itemStorage <= pcount
	then	itemStorage := []
	else	itemStorage := [itemStorage(x) | x in set inds itemStorage & x <= len itemStorage - pcount];

public RemoveBoxes : nat ==> ()
RemoveBoxes(pcount) ==
	if len boxStorage <= pcount
	then	boxStorage := []
	else	boxStorage := [boxStorage(x) | x in set inds boxStorage & x <= len boxStorage - pcount];

end Storage